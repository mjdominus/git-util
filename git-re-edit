#!/usr/bin/perl
#
# Run the editor on all the files that have been modified from the
# current index.  Useful to resume work when you left the working tree
# dirty.  Useful following a "git reset HEAD^" to continue work on the
# stuff you were working on before.  Useful following a failed merge.

use strict;
use Getopt::Std;
my $EDITOR = $ENV{VISUAL} || $ENV{EDITOR} || "emacs";
my %opt = ( e => $EDITOR,
            c => 0,
            'q' => 0,
          );
getopts('e:cq', \%opt) or usage();

run(shift);

sub run {
    my $commit = shift;

    my @command = (qw(git dirtyfiles),
                   ($opt{q} ? ('-q') : ()),
                   (defined($commit) ? ($commit) : ()),
        );

    if ($opt{c}) {
        exec @command
            or die "Couldn't run @command: $!";
    }

    my @files;
    {
        local $ENV{GIT_DIRTYFILES_NULSEP} = 1;
        open my ($f), "-|", @command
            or die "Couldn't run @command: $!";
        local $/ = "\0";
        chomp(@files = <$f>);
        close $f
            or die sprintf "git-dirtyfiles failed with exit status %d\n", $? >> 8;
    }

    unless (@files) {
        return run('HEAD') if ! defined $commit;
        warn "No files to edit\n";
        exit;
    }

    # maybe should use output of "git var GIT_EDITOR" here?
    # But then I have to involve the !@&*!@*(&!@ shell
    my $ed = $opt{e};
    exec $ed, @files;
    die "exec $ed: $!\n";
}

sub usage {
    print STDERR "git re-edit [-cq] [-e editor] [commit]
    edit the files in the working tree that are different since the last commit

    With -q, also edit files that are unknown to Git.
    With -c, print what would be edited but don't run the editor. (Deprecated, use git-dirtyfiles instead.)

    With a commit, edit the files that were changed in that commit.

    The default editor is $EDITOR; override with \$VISUAL, \$EDITOR, or with -e.
";
    exit 2;
}
